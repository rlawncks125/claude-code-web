name: write-test
description: Write comprehensive tests for Elysia.js application
instructions: |
  Write tests using Bun's test runner for both API endpoints and service layer.

  ## Testing Stack

  - Test Runner: Bun (`bun:test`)
  - Test Types: Integration (API) + Unit (Service)
  - Database: In-memory SQLite for unit tests

  ## Integration Tests (API Endpoints)

  ### File: tests/{entity}.test.ts

  Test full API endpoints end-to-end:

  ```typescript
  import { describe, test, expect } from "bun:test";
  import { app } from "../src/index";

  describe("User API Tests", () => {
    const baseUrl = "http://localhost:3000/api/v1/users";

    describe("GET /users", () => {
      test("should return all users", async () => {
        const response = await app.handle(new Request(baseUrl));
        expect(response.status).toBe(200);
        const data = await response.json();
        expect(Array.isArray(data)).toBe(true);
      });
    });

    describe("POST /users", () => {
      test("should create a new user", async () => {
        const response = await app.handle(
          new Request(baseUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name: "홍길동",
              email: "hong@example.com",
            }),
          })
        );
        expect(response.status).toBe(200);
        const data = await response.json();
        expect(data.name).toBe("홍길동");
        expect(data.email).toBe("hong@example.com");
        expect(data.id).toBeDefined();
      });

      test("should return validation error for missing fields", async () => {
        const response = await app.handle(
          new Request(baseUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({}),
          })
        );
        expect(response.status).toBe(422); // Elysia validation error
      });

      test("should return validation error for invalid email", async () => {
        const response = await app.handle(
          new Request(baseUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name: "Test",
              email: "invalid-email",
            }),
          })
        );
        expect(response.status).toBe(422);
      });
    });

    describe("GET /users/:id", () => {
      test("should return user by ID", async () => {
        // Create user first
        const createResponse = await app.handle(
          new Request(baseUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name: "Test User",
              email: "test@test.com",
            }),
          })
        );
        const created = await createResponse.json();

        // Get user
        const response = await app.handle(
          new Request(`${baseUrl}/${created.id}`)
        );
        expect(response.status).toBe(200);
        const data = await response.json();
        expect(data.id).toBe(created.id);
      });

      test("should return 404 for non-existent user", async () => {
        const response = await app.handle(
          new Request(`${baseUrl}/99999`)
        );
        expect(response.status).toBe(404);
      });
    });

    describe("PUT /users/:id", () => {
      test("should update user", async () => {
        // Create user
        const createResponse = await app.handle(
          new Request(baseUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name: "Original",
              email: "original@test.com",
            }),
          })
        );
        const created = await createResponse.json();

        // Update user
        const response = await app.handle(
          new Request(`${baseUrl}/${created.id}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name: "Updated",
            }),
          })
        );
        expect(response.status).toBe(200);
        const data = await response.json();
        expect(data.name).toBe("Updated");
        expect(data.email).toBe("original@test.com");
      });
    });

    describe("DELETE /users/:id", () => {
      test("should delete user", async () => {
        // Create user
        const createResponse = await app.handle(
          new Request(baseUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name: "To Delete",
              email: "delete@test.com",
            }),
          })
        );
        const created = await createResponse.json();

        // Delete user
        const deleteResponse = await app.handle(
          new Request(`${baseUrl}/${created.id}`, { method: "DELETE" })
        );
        expect(deleteResponse.status).toBe(200);

        // Verify deletion
        const getResponse = await app.handle(
          new Request(`${baseUrl}/${created.id}`)
        );
        expect(getResponse.status).toBe(404);
      });
    });
  });
  ```

  ## Unit Tests (Service Layer)

  ### File: tests/{entity}.service.test.ts

  Test business logic in isolation:

  ```typescript
  import { describe, test, expect, beforeEach } from "bun:test";
  import { Database } from "bun:sqlite";
  import { UserService } from "../src/services/user.service";
  import { initializeSchema } from "../src/utils/database";

  describe("UserService Unit Tests", () => {
    let db: Database;

    beforeEach(() => {
      db = new Database(":memory:");
      initializeSchema(db);
    });

    describe("createUser", () => {
      test("should create a user successfully", () => {
        const user = UserService.createUser(db, {
          name: "홍길동",
          email: "hong@example.com",
        });

        expect(user.id).toBeDefined();
        expect(user.name).toBe("홍길동");
        expect(user.email).toBe("hong@example.com");
        expect(user.created_at).toBeDefined();
        expect(user.updated_at).toBeDefined();
      });

      test("should throw error for duplicate email", () => {
        UserService.createUser(db, {
          name: "User 1",
          email: "test@test.com",
        });

        try {
          UserService.createUser(db, {
            name: "User 2",
            email: "test@test.com",
          });
          expect(true).toBe(false); // Should not reach here
        } catch (error: any) {
          expect(error.code).toBe(409);
          expect(error.response).toBe("Email already exists");
        }
      });
    });

    describe("getAllUsers", () => {
      test("should return empty array when no users", () => {
        const users = UserService.getAllUsers(db);
        expect(users).toEqual([]);
        expect(users.length).toBe(0);
      });

      test("should return all users", () => {
        UserService.createUser(db, { name: "User 1", email: "user1@test.com" });
        UserService.createUser(db, { name: "User 2", email: "user2@test.com" });

        const users = UserService.getAllUsers(db);
        expect(users.length).toBe(2);

        const names = users.map((u) => u.name).sort();
        expect(names).toEqual(["User 1", "User 2"]);
      });
    });

    describe("getUserById", () => {
      test("should return user by ID", () => {
        const created = UserService.createUser(db, {
          name: "홍길동",
          email: "hong@example.com",
        });

        const user = UserService.getUserById(db, created.id);
        expect(user.id).toBe(created.id);
        expect(user.name).toBe("홍길동");
      });

      test("should throw 404 for non-existent user", () => {
        try {
          UserService.getUserById(db, 99999);
          expect(true).toBe(false);
        } catch (error: any) {
          expect(error.code).toBe(404);
          expect(error.response).toBe("User not found");
        }
      });
    });

    describe("updateUser", () => {
      test("should update user name", () => {
        const created = UserService.createUser(db, {
          name: "Original",
          email: "original@test.com",
        });

        const updated = UserService.updateUser(db, created.id, {
          name: "Updated",
        });

        expect(updated.name).toBe("Updated");
        expect(updated.email).toBe("original@test.com");
      });

      test("should throw error for duplicate email", () => {
        UserService.createUser(db, { name: "User 1", email: "user1@test.com" });
        const user2 = UserService.createUser(db, { name: "User 2", email: "user2@test.com" });

        try {
          UserService.updateUser(db, user2.id, { email: "user1@test.com" });
          expect(true).toBe(false);
        } catch (error: any) {
          expect(error.code).toBe(409);
          expect(error.response).toBe("Email already exists");
        }
      });

      test("should return same user if no changes", () => {
        const created = UserService.createUser(db, {
          name: "Test",
          email: "test@test.com",
        });

        const updated = UserService.updateUser(db, created.id, {});
        expect(updated.id).toBe(created.id);
        expect(updated.name).toBe(created.name);
      });
    });

    describe("deleteUser", () => {
      test("should delete user successfully", () => {
        const created = UserService.createUser(db, {
          name: "To Delete",
          email: "delete@test.com",
        });

        UserService.deleteUser(db, created.id);

        try {
          UserService.getUserById(db, created.id);
          expect(true).toBe(false);
        } catch (error: any) {
          expect(error.code).toBe(404);
        }
      });

      test("should throw error for non-existent user", () => {
        try {
          UserService.deleteUser(db, 99999);
          expect(true).toBe(false);
        } catch (error: any) {
          expect(error.code).toBe(404);
        }
      });
    });
  });
  ```

  ## Important Testing Patterns

  ### Error Testing with Elysia's status()

  ```typescript
  // ❌ WRONG - don't use expect().toThrow()
  test("wrong way", () => {
    expect(() => Service.method(db, 999)).toThrow();
  });

  // ✅ CORRECT - use try-catch
  test("correct way", () => {
    try {
      Service.method(db, 999);
      expect(true).toBe(false); // Should not reach
    } catch (error: any) {
      expect(error.code).toBe(404);
      expect(error.response).toBe("Not found");
    }
  });
  ```

  ### Status Codes (Elysia-specific)

  ```typescript
  // Elysia uses these status codes:
  // 200 - Success
  // 422 - Validation error (NOT 400!)
  // 404 - Not found
  // 409 - Conflict
  // 500 - Internal error

  test("validation error returns 422", async () => {
    const response = await app.handle(/* invalid request */);
    expect(response.status).toBe(422); // Not 400!
  });
  ```

  ### Array Testing (Order Not Guaranteed)

  ```typescript
  test("should return multiple items", () => {
    const items = Service.getAll(db);
    expect(items.length).toBe(2);

    // Don't test exact order, test existence
    const names = items.map(i => i.name).sort();
    expect(names).toEqual(["Item 1", "Item 2"]);
  });
  ```

  ## Running Tests

  ```bash
  bun test              # Run all tests
  bun test --watch      # Watch mode
  bun test user.test.ts # Specific file
  ```

  ## Test Coverage Checklist

  For each entity:
  - ✅ Get all (empty and with data)
  - ✅ Get by ID (success and 404)
  - ✅ Create (success, validation errors, duplicates)
  - ✅ Update (success, 404, validation, conflicts)
  - ✅ Delete (success and 404)
  - ✅ Business logic errors
  - ✅ Edge cases

  ## Best Practices

  - Use descriptive test names: "should {behavior} when {condition}"
  - Group related tests with `describe`
  - Use `beforeEach` for fresh database setup
  - Test both success and error paths
  - Test behavior, not implementation
  - Keep tests independent (no shared state)
  - Use `:memory:` database for speed in unit tests
  - Clean up resources after tests if needed
