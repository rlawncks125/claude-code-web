name: create-crud-entity
description: Create a new CRUD entity following Elysia.js Best Practice patterns
instructions: |
  Create a complete CRUD entity with Model, Service, Routes, Database schema, and Tests.

  ## Pattern Overview
  - Models: Namespace pattern with type extraction
  - Services: Abstract class with static methods (no instances)
  - Routes: Direct service calls (no controller layer)
  - Database: SQLite with bun:sqlite

  ## Steps to Follow

  ### 1. Create Model (src/models/{entity}.model.ts)

  Create a namespace with:
  - Entity interface for database structure
  - Validation schemas using Elysia's `t` (create, update, params)
  - Type extraction using `typeof schema.static`
  - Error literals for type-safe errors

  Example:
  ```typescript
  import { t } from "elysia";

  export namespace EntityModel {
    export interface Entity {
      id: number;
      name: string;
      created_at: string;
      updated_at: string;
    }

    export const create = t.Object({
      name: t.String({ minLength: 1, maxLength: 100 }),
    });
    export type Create = typeof create.static;

    export const update = t.Object({
      name: t.Optional(t.String({ minLength: 1, maxLength: 100 })),
    });
    export type Update = typeof update.static;

    export const params = t.Object({
      id: t.Numeric({ minimum: 1 }),
    });
    export type Params = typeof params.static;

    export const notFound = t.Literal("Entity not found");
    export type NotFound = typeof notFound.static;
  }
  ```

  ### 2. Create Service (src/services/{entity}.service.ts)

  Create abstract class with static methods:
  - First parameter is always `db: Database`
  - Throw errors using `status(code, message satisfies ErrorType)`
  - Include JSDoc comments

  Example:
  ```typescript
  import { status } from "elysia";
  import type { Database } from "bun:sqlite";
  import { EntityModel } from "../models/entity.model";

  export abstract class EntityService {
    static getAll(db: Database): EntityModel.Entity[] {
      const query = db.query("SELECT * FROM entities ORDER BY created_at DESC");
      return query.all() as EntityModel.Entity[];
    }

    static getById(db: Database, id: number): EntityModel.Entity {
      const query = db.query("SELECT * FROM entities WHERE id = ?");
      const entity = query.get(id) as EntityModel.Entity | undefined;

      if (!entity) {
        throw status(404, "Entity not found" satisfies EntityModel.NotFound);
      }
      return entity;
    }

    static create(db: Database, data: EntityModel.Create): EntityModel.Entity {
      const query = db.query("INSERT INTO entities (name) VALUES (?) RETURNING *");
      return query.get(data.name) as EntityModel.Entity;
    }

    static update(db: Database, id: number, data: EntityModel.Update): EntityModel.Entity {
      const entity = this.getById(db, id);

      if (!data.name) return entity;

      const query = db.query("UPDATE entities SET name = ? WHERE id = ? RETURNING *");
      return query.get(data.name, id) as EntityModel.Entity;
    }

    static delete(db: Database, id: number): void {
      this.getById(db, id);
      const query = db.query("DELETE FROM entities WHERE id = ?");
      query.run(id);
    }
  }
  ```

  ### 3. Create Routes (src/routes/{entity}.routes.ts)

  Create Elysia instance with prefix and call Service methods directly:

  ```typescript
  import { Elysia } from "elysia";
  import { EntityModel } from "../models/entity.model";
  import { EntityService } from "../services/entity.service";

  export const entityRoutes = new Elysia({ prefix: "/entities" })
    .get("/", ({ db }) => EntityService.getAll(db), {
      detail: { tags: ["Entities"], summary: "Get all entities" },
    })
    .get("/:id", ({ db, params }) => EntityService.getById(db, params.id), {
      params: EntityModel.params,
      detail: { tags: ["Entities"], summary: "Get entity by ID" },
    })
    .post("/", ({ db, body }) => EntityService.create(db, body), {
      body: EntityModel.create,
      detail: { tags: ["Entities"], summary: "Create new entity" },
    })
    .put("/:id", ({ db, params, body }) => EntityService.update(db, params.id, body), {
      params: EntityModel.params,
      body: EntityModel.update,
      detail: { tags: ["Entities"], summary: "Update entity" },
    })
    .delete("/:id", ({ db, params }) => {
      EntityService.delete(db, params.id);
      return { success: true, message: "Entity deleted successfully" };
    }, {
      params: EntityModel.params,
      detail: { tags: ["Entities"], summary: "Delete entity" },
    });
  ```

  ### 4. Update Database Schema (src/utils/database.ts)

  Add table creation in initializeSchema():

  ```typescript
  db.run(`
    CREATE TABLE IF NOT EXISTS entities (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
  `);

  db.run(`
    CREATE TRIGGER IF NOT EXISTS update_entity_timestamp
    AFTER UPDATE ON entities
    FOR EACH ROW
    BEGIN
      UPDATE entities SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.id;
    END
  `);
  ```

  ### 5. Register Routes (src/routes/index.ts)

  Import and add to routes:

  ```typescript
  import { entityRoutes } from "./entity.routes";

  export const routes = new Elysia({ prefix: "/api/v1" })
    .get("/health", () => ({ status: "ok" }))
    .use(entityRoutes);
  ```

  ### 6. Create Tests

  Create tests/entity.test.ts (integration) and tests/entity.service.test.ts (unit).

  Integration test:
  ```typescript
  import { describe, test, expect } from "bun:test";
  import { app } from "../src/index";

  describe("Entity API", () => {
    test("should create entity", async () => {
      const response = await app.handle(
        new Request("http://localhost:3000/api/v1/entities", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name: "Test" }),
        })
      );
      expect(response.status).toBe(200);
    });
  });
  ```

  Unit test:
  ```typescript
  import { describe, test, expect, beforeEach } from "bun:test";
  import { Database } from "bun:sqlite";
  import { EntityService } from "../src/services/entity.service";
  import { initializeSchema } from "../src/utils/database";

  describe("EntityService", () => {
    let db: Database;

    beforeEach(() => {
      db = new Database(":memory:");
      initializeSchema(db);
    });

    test("should create entity", () => {
      const entity = EntityService.create(db, { name: "Test" });
      expect(entity.name).toBe("Test");
    });
  });
  ```

  ### 7. Run Tests

  ```bash
  bun test
  ```

  ## Important Notes
  - Use namespace for models (not separate files)
  - Use abstract class with static methods for services (no instances)
  - Routes call service methods directly (no controller layer)
  - Always validate with Elysia schemas
  - Use `status(code, message satisfies Type)` for type-safe errors
  - Test both API endpoints and service layer
